#include <bits/stdc++.h>

using namespace std;

class Solution {
 public:
  int numIslands(vector<vector<char>> &grid) {
    // 0: not discovered
    // 1: added
    // 2: travelled
    vector<vector<int>> travelled;
    travelled.reserve(grid.size());

    // init travelled
    for (int i = 0; i < grid.size(); ++i) {
      auto &f = travelled.emplace_back();
      f.reserve(grid[0].size());
      for (int j = 0; j < grid[0].size(); ++j) {
        f.push_back(0);
        grid[i][j] -= '0';
      }
    }

    queue<pair<int, int>> q; // <i, j> location

    auto within_range = [&](int i, int j) {
      return (i >= 0 && i < grid.size()) && (j >= 0 && j < grid[0].size());
    };
    auto not_travelled = [&](int i, int j) {
      return within_range(i, j) && grid[i][j] && !travelled[i][j];
    };
    auto add_surrounding_not_travelled = [&](int i, int j) {
      static int offsets[][2] = {
          {1,  0},
          {-1, 0},
          {0,  1},
          {0,  -1}
      };
      for (auto [x, y]: offsets) {
        if (not_travelled(i + x, j + y)) {
          travelled[i + x][j + y] = 1;
          q.push({i + x, j + y});
        }
      }
    };

    int island_cnt = 0;

    for (int i = 0; i < grid.size(); ++i) {
      for (int j = 0; j < grid[0].size(); ++j) {
        if (grid[i][j] && !travelled[i][j]) {
          q.push({i, j});
          ++island_cnt;
        }
        while (!q.empty()) {
          auto [x, y] = q.front();
          q.pop();
          add_surrounding_not_travelled(x, y);
        }
      }
    }

    return island_cnt;
  }
};

int main() {
  vector<vector<char>> grid{{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1'},
                            {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0'},
                            {'1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1'},
                            {'0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
                            {'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '0'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
                            {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}};

  Solution s;
  std::cout << s.numIslands(grid) << std::endl;

  return 0;
}